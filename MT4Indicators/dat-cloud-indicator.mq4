/*
   Generated by EX4-TO-MQ4 decompiler V4.0.224.1 []
   Website: http://purebeam.biz
   E-mail : purebeam@gmail.com
*/
#property copyright ""
#property link      ""

#property indicator_chart_window
#property indicator_buffers 4
#property indicator_color1 CornflowerBlue
#property indicator_color2 Violet
#property indicator_color3 CornflowerBlue
#property indicator_color4 Violet

string gs_76;
string gs_unused_84;
extern int Tenkan = 9;
extern int Kijun = 26;
extern int Senkou = 52;
extern int SMA_Period1 = 55;
extern int SMA_Period2 = 30;
extern double b = 0.3;
extern bool Shift = FALSE;
extern int FuturePeriod = 28;
extern bool Show_Title = TRUE;
extern bool Show_Value = FALSE;
extern int CalculateBars = 500;
double g_ibuf_140[];
double g_ibuf_144[];
double g_ibuf_148[];
double g_ibuf_152[];
int gi_156;
double gda_160[];
double gda_164[];
double gda_168[];
double gda_172[];
double gda_176[];
double gda_180[];
double gda_184[];
double gda_188[];
double gd_192;
double gd_200;
double gd_208;
double gd_216;
double gd_224;
double gd_232;
double gd_240;
double gd_248;
double gd_256;
int gi_264 = 0;


int init() {
   gi_156 = Kijun;
   if (gi_156 < Tenkan) gi_156 = Tenkan;
   int l_timeframe_0 = Period();
   switch (l_timeframe_0) {
   case PERIOD_M1:
      gs_unused_84 = "M1";
      break;
   case PERIOD_M5:
      gs_unused_84 = "M5";
      break;
   case PERIOD_M15:
      gs_unused_84 = "M15";
      break;
   case PERIOD_M30:
      gs_unused_84 = "M30";
      break;
   case PERIOD_H1:
      gs_unused_84 = "H1";
      break;
   case PERIOD_H4:
      gs_unused_84 = "H4";
      break;
   case PERIOD_D1:
      gs_unused_84 = "D1";
      break;
   case PERIOD_W1:
      gs_unused_84 = "W1";
      break;
   case PERIOD_MN1:
      gs_unused_84 = "MN1";
      break;
   default:
      gs_unused_84 = "";
   }
   gs_76 = "DAT_Cloud";
   if (Show_Title == FALSE) gs_76 = "";
   IndicatorShortName(gs_76);
   SetIndexBuffer(0, g_ibuf_140);
   SetIndexBuffer(1, g_ibuf_144);
   SetIndexBuffer(2, g_ibuf_148);
   SetIndexBuffer(3, g_ibuf_152);
   SetIndexLabel(0, NULL);
   SetIndexLabel(1, NULL);
   SetIndexLabel(2, "Span A");
   SetIndexLabel(3, "Span B");
   if (!Show_Value) {
      SetIndexLabel(0, NULL);
      SetIndexLabel(1, NULL);
      SetIndexLabel(2, NULL);
      SetIndexLabel(3, NULL);
   }
   SetIndexStyle(0, DRAW_HISTOGRAM);
   SetIndexStyle(1, DRAW_HISTOGRAM);
   SetIndexStyle(2, DRAW_LINE);
   SetIndexStyle(3, DRAW_LINE);
   SetIndexDrawBegin(0, Kijun + gi_156 - 1);
   SetIndexDrawBegin(1, Kijun + Senkou - 1);
   SetIndexDrawBegin(2, Kijun + gi_156 - 1);
   SetIndexDrawBegin(3, Kijun + Senkou - 1);
   if (CalculateBars > 0) {
      SetIndexDrawBegin(0, Bars - CalculateBars);
      SetIndexDrawBegin(1, Bars - CalculateBars);
      SetIndexDrawBegin(2, Bars - CalculateBars);
      SetIndexDrawBegin(3, Bars - CalculateBars);
   }
   if (Shift) gi_264 = Kijun;
   if (FuturePeriod > 0) gi_264 += FuturePeriod;
   if (gi_264 >= 0) {
      SetIndexShift(0, gi_264);
      SetIndexShift(1, gi_264);
      SetIndexShift(2, gi_264);
      SetIndexShift(3, gi_264);
   }
   return (0);
}

int start() {
   int li_8 = CalculateBars;
   THV_T3(SMA_Period2);
   for (int li_0 = li_8 - 1; li_0 >= 0; li_0--) {
      g_ibuf_140[li_0] = gda_160[li_0];
      g_ibuf_148[li_0] = gda_160[li_0];
   }
   THV_T3(SMA_Period1);
   for (li_0 = li_8 - 1; li_0 >= 0; li_0--) {
      g_ibuf_144[li_0] = gda_160[li_0];
      g_ibuf_152[li_0] = gda_160[li_0];
   }
   return (0);
}

void THV_T3(int ai_0) {
   double ld_12;
   double ld_20;
   double ld_28;
   int li_4 = CalculateBars - 1;
   gd_192 = 0;
   gd_200 = 0;
   gd_208 = 0;
   gd_216 = 0;
   gd_224 = 0;
   gd_232 = 0;
   gd_240 = 0;
   gd_248 = 0;
   gd_256 = 0;
   gd_248 = b * b;
   gd_256 = gd_248 * b;
   gd_192 = -gd_256;
   gd_200 = 3.0 * (gd_248 + gd_256);
   gd_208 = -3.0 * (2.0 * gd_248 + b + gd_256);
   gd_216 = 3.0 * b + 1.0 + gd_256 + 3.0 * gd_248;
   gd_224 = ai_0;
   if (gd_224 < 1.0) gd_224 = 1;
   gd_224 = (gd_224 - 1.0) / 2.0 + 1.0;
   gd_232 = 2 / (gd_224 + 1.0);
   gd_240 = 1 - gd_232;
   ArrayResize(gda_168, CalculateBars + 1);
   ArrayResize(gda_172, CalculateBars + 1);
   ArrayResize(gda_176, CalculateBars + 1);
   ArrayResize(gda_180, CalculateBars + 1);
   ArrayResize(gda_184, CalculateBars + 1);
   ArrayResize(gda_188, CalculateBars + 1);
   ArrayResize(gda_160, li_4);
   ArrayResize(gda_164, li_4);
   if (FuturePeriod <= 0) for (int li_8 = li_4; li_8 >= 0; li_8--) gda_164[li_8] = Close[li_8];
   else {
      for (li_8 = li_4; li_8 >= 0; li_8--) gda_164[li_8 + FuturePeriod] = Close[li_8];
      ld_28 = 1.0;
      ld_20 = FTR_Spectrum(FuturePeriod) * Point;
      ld_12 = iClose(NULL, 0, 0) - FTR_Spectrum(FuturePeriod) * Point;
      for (li_8 = FuturePeriod - 1; li_8 >= 0; li_8--) {
         ld_20 = FTR_Spectrum(li_8) * Point * ld_28;
         gda_164[li_8] = ld_12 + ld_20;
      }
   }
   for (li_8 = li_4 - FuturePeriod; li_8 >= 0; li_8--) {
      gda_168[CalculateBars - li_8] = gd_232 * gda_164[li_8] + gd_240 * (gda_168[CalculateBars - li_8 - 1]);
      gda_172[CalculateBars - li_8] = gd_232 * (gda_168[CalculateBars - li_8]) + gd_240 * (gda_172[CalculateBars - li_8 - 1]);
      gda_176[CalculateBars - li_8] = gd_232 * (gda_172[CalculateBars - li_8]) + gd_240 * (gda_176[CalculateBars - li_8 - 1]);
      gda_180[CalculateBars - li_8] = gd_232 * (gda_176[CalculateBars - li_8]) + gd_240 * (gda_180[CalculateBars - li_8 - 1]);
      gda_184[CalculateBars - li_8] = gd_232 * (gda_180[CalculateBars - li_8]) + gd_240 * (gda_184[CalculateBars - li_8 - 1]);
      gda_188[CalculateBars - li_8] = gd_232 * (gda_184[CalculateBars - li_8]) + gd_240 * (gda_188[CalculateBars - li_8 - 1]);
      gda_160[li_8] = gd_192 * (gda_188[CalculateBars - li_8]) + gd_200 * (gda_184[CalculateBars - li_8]) + gd_208 * (gda_180[CalculateBars - li_8]) + gd_216 * (gda_176[CalculateBars - li_8]);
   }
}

double FTR_Spectrum(int ai_0) {
   int li_4;
   double ld_ret_12;
   if (ai_0 - FuturePeriod < 0) li_4 = 0;
   else li_4 = ai_0 - FuturePeriod;
   for (int li_8 = ai_0; li_8 >= li_4; li_8--) ld_ret_12 += (iClose(NULL, 0, li_8) - iOpen(NULL, 0, li_8)) / Point;
   return (ld_ret_12);
}